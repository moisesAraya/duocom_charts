"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatementImpl = void 0;
const resultset_1 = require("./resultset");
const impl_1 = require("node-firebird-driver/dist/lib/impl");
const fb_util_1 = require("./fb-util");
const fb = require("node-firebird-native-api");
const util_1 = require("util");
/** Statement implementation. */
class StatementImpl extends impl_1.AbstractStatement {
    static async prepare(attachment, transaction, sqlStmt, _options) {
        const statement = new StatementImpl(attachment);
        return await attachment.client.statusAction(async (status) => {
            //// FIXME: options/flags, dialect
            statement.statementHandle = await attachment.attachmentHandle.prepareAsync(status, transaction?.transactionHandle, 0, sqlStmt, 3, fb.Statement.PREPARE_PREFETCH_ALL);
            statement.hasResultSet = (statement.statementHandle.getFlagsSync(status) & fb.Statement.FLAG_HAS_CURSOR) != 0;
            statement.inMetadata = (0, fb_util_1.fixMetadata)(status, await statement.statementHandle.getInputMetadataAsync(status));
            statement.outMetadata = (0, fb_util_1.fixMetadata)(status, await statement.statementHandle.getOutputMetadataAsync(status));
            if (statement.inMetadata) {
                statement.inBuffer = new Uint8Array(statement.inMetadata.getMessageLengthSync(status));
                statement.dataWriter = (0, fb_util_1.createDataWriter)((0, fb_util_1.createDescriptors)(status, statement.inMetadata));
            }
            if (statement.outMetadata) {
                statement.outBuffer = new Uint8Array(statement.outMetadata.getMessageLengthSync(status));
                statement.dataReader = (0, fb_util_1.createDataReader)((0, fb_util_1.createDescriptors)(status, statement.outMetadata));
            }
            return statement;
        });
    }
    /** Disposes this statement's resources. */
    async internalDispose() {
        if (this.outMetadata) {
            this.outMetadata.releaseSync();
            this.outMetadata = undefined;
        }
        if (this.inMetadata) {
            this.inMetadata.releaseSync();
            this.inMetadata = undefined;
        }
        await this.attachment.client.statusAction((status) => this.statementHandle.freeAsync(status));
        this.statementHandle = undefined;
    }
    /** Executes a prepared statement that uses the SET TRANSACTION command. Returns the new transaction. */
    async internalExecuteTransaction(_transaction) {
        throw new Error('Uninplemented method: executeTransaction.');
    }
    /** Executes a prepared statement that has no result set. */
    async internalExecute(transaction, parameters, _options) {
        return await this.attachment.client.statusAction(async (status) => {
            await this.dataWriter(this.attachment, transaction, this.inBuffer, parameters);
            const newTransaction = await this.statementHandle.executeAsync(status, transaction?.transactionHandle, this.inMetadata, this.inBuffer, this.outMetadata, this.outBuffer);
            if (newTransaction && transaction?.transactionHandle != newTransaction) {
                //// FIXME: newTransaction.releaseSync();
            }
            return this.outMetadata ? await this.dataReader(this.attachment, transaction, this.outBuffer) : [];
        });
    }
    /** Executes a prepared statement that has result set. */
    async internalExecuteQuery(transaction, parameters, options) {
        return await resultset_1.ResultSetImpl.open(this, transaction, parameters, options);
    }
    async setCursorName(cursorName) {
        return await this.attachment.client.statusAction(async (status) => await this.statementHandle.setCursorNameAsync(status, cursorName));
    }
    async getExecPathText() {
        return await this.attachment.client.statusAction(async (status) => {
            const infoReq = new Uint8Array([impl_1.statementInfo.sqlExecPathBlrText]);
            const infoRet = new Uint8Array(65535);
            await this.statementHandle.getInfoAsync(status, infoReq.byteLength, infoReq, infoRet.byteLength, infoRet);
            if (infoRet[0] == impl_1.commonInfo.end) {
                return undefined;
            }
            else {
                if (infoRet[0] != impl_1.statementInfo.sqlExecPathBlrText) {
                    throw new Error('Error retrieving statement execution path.');
                }
                const size = (0, impl_1.getPortableInteger)(infoRet.subarray(1), 2);
                return new util_1.TextDecoder().decode(infoRet.subarray(3, 3 + size));
            }
        });
    }
    get columnLabels() {
        const asyncFunc = async () => {
            if (!this.outMetadata) {
                return [];
            }
            return await this.attachment.client.statusAction(async (status) => {
                const metaData = this.outMetadata;
                const count = metaData.getCountSync(status);
                const array = [];
                for (let i = 0; i < count; ++i) {
                    array.push(metaData.getAliasSync(status, i));
                }
                return array;
            });
        };
        return asyncFunc();
    }
}
exports.StatementImpl = StatementImpl;
//# sourceMappingURL=statement.js.map