"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobStreamImpl = void 0;
const node_firebird_driver_1 = require("node-firebird-driver");
const impl_1 = require("node-firebird-driver/dist/lib/impl");
const fb = require("node-firebird-native-api");
const MAX_SEGMENT_SIZE = 65535;
/** BlobStream implementation. */
class BlobStreamImpl extends impl_1.AbstractBlobStream {
    static async create(attachment, transaction, options) {
        return await attachment.client.statusAction(async (status) => {
            const blobId = new Uint8Array(8);
            const bpb = (0, impl_1.createBpb)(options);
            const blobHandle = await attachment.attachmentHandle.createBlobAsync(status, transaction.transactionHandle, blobId, bpb.length, bpb);
            const blob = new node_firebird_driver_1.Blob(attachment, blobId);
            const blobStream = new BlobStreamImpl(blob, attachment);
            blobStream.blobHandle = blobHandle;
            return blobStream;
        });
    }
    static async open(attachment, transaction, blob) {
        return await attachment.client.statusAction(async (status) => {
            const blobStream = new BlobStreamImpl(blob, attachment);
            blobStream.blobHandle = await attachment.attachmentHandle.openBlobAsync(status, transaction.transactionHandle, blob.id, 0, undefined);
            return blobStream;
        });
    }
    async internalGetLength() {
        return await this.attachment.client.statusAction(async (status) => {
            const infoReq = new Uint8Array([impl_1.blobInfo.totalLength]);
            const infoRet = new Uint8Array(20);
            await this.blobHandle.getInfoAsync(status, infoReq.byteLength, infoReq, infoRet.byteLength, infoRet);
            if (infoRet[0] != impl_1.blobInfo.totalLength)
                throw new Error('Unrecognized response from Blob::getInfo.');
            const size = (0, impl_1.getPortableInteger)(infoRet.subarray(1), 2);
            return (0, impl_1.getPortableInteger)(infoRet.subarray(3), size);
        });
    }
    async internalClose() {
        await this.attachment.client.statusAction(status => this.blobHandle.closeAsync(status));
        this.blobHandle = undefined;
    }
    async internalCancel() {
        await this.attachment.client.statusAction(status => this.blobHandle.cancelAsync(status));
        this.blobHandle = undefined;
    }
    async internalSeek(offset, whence) {
        return await this.attachment.client.statusAction(async (status) => {
            return await this.blobHandle.seekAsync(status, whence ?? node_firebird_driver_1.BlobSeekWhence.START, offset);
        });
    }
    async internalRead(buffer) {
        return await this.attachment.client.statusAction(async (status) => {
            const readingBytes = Math.min(buffer.length, MAX_SEGMENT_SIZE);
            const segLength = new Uint32Array(1);
            const result = await this.blobHandle.getSegmentAsync(status, readingBytes, buffer, segLength);
            if (result == fb.Status.RESULT_NO_DATA)
                return -1;
            return segLength[0];
        });
    }
    async internalWrite(buffer) {
        await this.attachment.client.statusAction(async (status) => {
            while (buffer.length > 0) {
                const writingBytes = Math.min(buffer.length, MAX_SEGMENT_SIZE);
                await this.blobHandle.putSegmentAsync(status, writingBytes, buffer);
                buffer = buffer.slice(writingBytes);
            }
        });
    }
    get isValid() {
        return !!this.blobHandle && this.attachment.isValid;
    }
}
exports.BlobStreamImpl = BlobStreamImpl;
//# sourceMappingURL=blob.js.map