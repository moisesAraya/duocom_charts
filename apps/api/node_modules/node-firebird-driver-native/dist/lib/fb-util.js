"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixMetadata = fixMetadata;
exports.createDescriptors = createDescriptors;
const impl_1 = require("node-firebird-driver/dist/lib/impl");
__exportStar(require("node-firebird-driver/dist/lib/impl"), exports);
/** Fix metadata descriptors to types we want to read. */
function fixMetadata(status, metadata) {
    if (!metadata) {
        return undefined;
    }
    let ret;
    const outBuilder = metadata.getBuilderSync(status);
    try {
        for (let i = metadata.getCountSync(status) - 1; i >= 0; --i) {
            switch (metadata.getTypeSync(status, i)) {
                // Transform CHAR descriptors to VARCHAR.
                case impl_1.sqlTypes.SQL_TEXT:
                    outBuilder.setTypeSync(status, i, impl_1.sqlTypes.SQL_VARYING);
                    break;
                // Transform numeric descriptors to DOUBLE PRECISION.
                case impl_1.sqlTypes.SQL_SHORT:
                case impl_1.sqlTypes.SQL_LONG:
                case impl_1.sqlTypes.SQL_INT64:
                case impl_1.sqlTypes.SQL_FLOAT:
                    outBuilder.setTypeSync(status, i, impl_1.sqlTypes.SQL_DOUBLE);
                    outBuilder.setLengthSync(status, i, 8);
                    outBuilder.setScaleSync(status, i, 0);
                    break;
                // Transform TIME_TZ to TIME_TZ_EX.
                case impl_1.sqlTypes.SQL_TIME_TZ:
                    outBuilder.setTypeSync(status, i, impl_1.sqlTypes.SQL_TIME_TZ_EX);
                    break;
                // Transform TIMESTAMP_TZ to TIMESTAMP_TZ_EX.
                case impl_1.sqlTypes.SQL_TIMESTAMP_TZ:
                    outBuilder.setTypeSync(status, i, impl_1.sqlTypes.SQL_TIMESTAMP_TZ_EX);
                    break;
                // Transform INT128, DEC16 and DEC34 descriptors to VARCHAR.
                case impl_1.sqlTypes.SQL_INT128:
                case impl_1.sqlTypes.SQL_DEC16:
                case impl_1.sqlTypes.SQL_DEC34:
                    outBuilder.setTypeSync(status, i, impl_1.sqlTypes.SQL_VARYING);
                    outBuilder.setLengthSync(status, i, 45);
                    outBuilder.setCharSetSync(status, i, impl_1.charSets.ascii);
                    break;
            }
        }
        ret = outBuilder.getMetadataSync(status);
    }
    finally {
        outBuilder.releaseSync();
    }
    metadata.releaseSync();
    return ret;
}
function createDescriptors(status, metadata) {
    if (!metadata) {
        return [];
    }
    const count = metadata.getCountSync(status);
    const ret = [];
    for (let i = 0; i < count; ++i) {
        ret.push({
            type: metadata.getTypeSync(status, i),
            subType: metadata.getSubTypeSync(status, i),
            nullOffset: metadata.getNullOffsetSync(status, i),
            offset: metadata.getOffsetSync(status, i),
            length: metadata.getLengthSync(status, i),
            scale: metadata.getScaleSync(status, i),
        });
    }
    return ret;
}
//# sourceMappingURL=fb-util.js.map