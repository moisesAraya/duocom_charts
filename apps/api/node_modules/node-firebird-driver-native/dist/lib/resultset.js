"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResultSetImpl = void 0;
const impl_1 = require("node-firebird-driver/dist/lib/impl");
const fb = require("node-firebird-native-api");
/** ResultSet implementation. */
class ResultSetImpl extends impl_1.AbstractResultSet {
    static async open(statement, transaction, parameters, options) {
        const resultSet = new ResultSetImpl(statement, transaction);
        return await statement.attachment.client.statusAction(async (status) => {
            //// FIXME: options
            await statement.dataWriter(statement.attachment, transaction, statement.inBuffer, parameters);
            resultSet.resultSetHandle = await statement.statementHandle.openCursorAsync(status, transaction.transactionHandle, statement.inMetadata, statement.inBuffer, statement.outMetadata, 0);
            return resultSet;
        });
    }
    /** Closes this result set. */
    async internalClose() {
        await this.statement.attachment.client.statusAction(async (status) => {
            await this.resultSetHandle.closeAsync(status);
            this.resultSetHandle = undefined;
        });
    }
    /** Fetchs data from this result set. */
    async internalFetch(options) {
        return await this.statement.attachment.client.statusAction(async (status) => {
            if (this.delayedError) {
                const error = this.delayedError;
                this.delayedError = undefined;
                throw error;
            }
            const rows = [];
            const buffers = [this.statement.outBuffer, new Uint8Array(this.statement.outMetadata.getMessageLengthSync(status))];
            let buffer = 0;
            let nextFetchPromise = this.resultSetHandle.fetchNextAsync(status, buffers[buffer]);
            while (true) {
                let nextFetch;
                try {
                    nextFetch = await nextFetchPromise;
                }
                catch (e) {
                    if (rows.length == 0)
                        throw e;
                    else {
                        this.delayedError = e;
                        return { finished: false, rows };
                    }
                }
                if (nextFetch == fb.Status.RESULT_OK) {
                    const buffer1 = buffer;
                    buffer = ++buffer % 2;
                    const finish = options && options.fetchSize && rows.length + 1 >= options.fetchSize;
                    if (!finish)
                        nextFetchPromise = this.resultSetHandle.fetchNextAsync(status, buffers[buffer]);
                    rows.push(await this.statement.dataReader(this.statement.attachment, this.transaction, buffers[buffer1]));
                    if (finish)
                        return { finished: false, rows };
                }
                else {
                    return { finished: true, rows };
                }
            }
        });
    }
}
exports.ResultSetImpl = ResultSetImpl;
//# sourceMappingURL=resultset.js.map