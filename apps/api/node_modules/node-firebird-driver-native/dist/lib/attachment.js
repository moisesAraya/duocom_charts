"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttachmentImpl = void 0;
const blob_1 = require("./blob");
const statement_1 = require("./statement");
const transaction_1 = require("./transaction");
const events_1 = require("./events");
const fb_util_1 = require("./fb-util");
const impl_1 = require("node-firebird-driver/dist/lib/impl");
/** Attachment implementation. */
class AttachmentImpl extends impl_1.AbstractAttachment {
    static async connect(client, uri, options) {
        const attachment = new AttachmentImpl(client);
        return await client.statusAction(async (status) => {
            const dpb = (0, fb_util_1.createDpb)(options);
            attachment.attachmentHandle = await client.dispatcher.attachDatabaseAsync(status, uri, dpb.length, dpb);
            return attachment;
        });
    }
    static async createDatabase(client, uri, options) {
        const attachment = new AttachmentImpl(client);
        return await client.statusAction(async (status) => {
            const dpb = (0, fb_util_1.createDpb)(options);
            attachment.attachmentHandle = await client.dispatcher.createDatabaseAsync(status, uri, dpb.length, dpb);
            return attachment;
        });
    }
    /** Disconnects this attachment. */
    async internalDisconnect() {
        await this.client.statusAction(status => this.attachmentHandle.detachAsync(status));
        this.attachmentHandle = undefined;
    }
    /** Drops the database and release this attachment. */
    async internalDropDatabase() {
        await this.client.statusAction(status => this.attachmentHandle.dropDatabaseAsync(status));
        this.attachmentHandle = undefined;
    }
    /** Enable/disable cancellation of operations in this attachment. */
    async internalEnableCancellation(enable) {
        await this.client.statusAction(status => this.attachmentHandle.cancelOperationAsync(status, (enable ? impl_1.cancelType.enable : impl_1.cancelType.disable)));
    }
    /** Cancel a running operation in this attachment. */
    async internalCancelOperation(forcibleAbort) {
        await this.client.statusAction(status => this.attachmentHandle.cancelOperationAsync(status, (forcibleAbort ? impl_1.cancelType.abort : impl_1.cancelType.raise)));
    }
    /** Starts a new transaction. */
    async internalStartTransaction(options) {
        return await transaction_1.TransactionImpl.start(this, options);
    }
    async internalCreateBlob(transaction, options) {
        return await blob_1.BlobStreamImpl.create(this, transaction, options);
    }
    async internalOpenBlob(transaction, blob) {
        return await blob_1.BlobStreamImpl.open(this, transaction, blob);
    }
    /** Prepares a query. */
    async internalPrepare(transaction, sqlStmt, options) {
        return await statement_1.StatementImpl.prepare(this, transaction, sqlStmt, options);
    }
    async internalQueueEvents(names, callBack) {
        return await events_1.EventsImpl.queue(this, names, callBack);
    }
}
exports.AttachmentImpl = AttachmentImpl;
//# sourceMappingURL=attachment.js.map